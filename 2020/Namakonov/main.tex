% Intended LaTeX compiler: xelatex

\input{Namakonov/preamble}

% \bibliography{Namakonov/sources}

\hyphenation{%
  не-сог-ла-со-ван-ность
}

% \begin{document}

% \filltitle{ru}{
%     chair              = {Кафедра системного программирования},
%     title              = {Компиляция модели памяти OCaml в Power},
%     type               = {master},
%     position           = {студента},
%     group              = 18.М08-мкн,
%     author             = {Намаконов Егор Сергеевич},
%     supervisor         = {Кознов Д.\,В.},
%     supervisorPosition = {д.ф.-м.н.},
%     reviewer           = {Березун Д. А.},
%     reviewerPosition   = {к.ф.-м.н.},
%     consultant         = {Подкопаев А.В.},
%     consultantPosition = {к.ф.-м.н.},
%     % chairHead          = {Хунта К.\,Х.},
%     % chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
%   university         = {Санкт-Петербургский государственный университет},
%   faculty            = {Математическое обеспечение и администрирование информационных систем},
%   city               = {Санкт-Петербург},
%   year               = {2020}
% }
% \filltitle{en}{
%     chair              = {Software Engineering},
%     title              = {Compilation of OCaml memory model to Power},
%     author             = {Egor Namakonov},
%     supervisorPosition = {D. Sc.},
%     supervisor         = {Dmitri Koznov},
%     consultant         = {Anton Podkopaev},
%     consultantPosition = {Ph.D.},
%     reviewer           = {Daniil Berezun},
%     reviewerPosition   = {Ph.D.},
%     faculty            = {Software and Administration of Information Systems},
%     % chairHeadPosition  = {professor},
%     % chairHead          = {Christobal Junta},
% }

% \maketitle

% % \begin{abstract}
% % \end{abstract}
% % {\bf Ключевые слова:} слабые модели памяти, корректность компиляции, многопоточность.
% \newgeometry{a4paper,top=20mm,bottom=20mm,left=30mm,right=15mm,nohead,includeheadfoot} % for some reason it's ignored when placed in cls file

\tableofcontents



\section{Введение}

Результат исполнения многопоточной программы, как правило, является недетерминированным. Конкретное множество допустимых результатов многопоточной программы определяется \defin{моделью памяти} языка программирования. Наиболее известной является   \defin{модель последовательной согласованности} (\foreignlanguage{english}{sequential consistency}, SC \cite{sc}). Она предполагает, что любой результат исполнения программы может быть получен путём попеременного исполнения инструкций отдельных потоков согласно программному порядку в них. Однако из-за оптимизаций, выполняемых современными компиляторами и процессорами, могут наблюдаться сценарии поведения, невозможные в такой модели. Так, на архитектуре x86 чтение по адресу в памяти может вернуть не самое последнее записанное значение, так как операция записи может быть буферизована. 

Отказ от подобных оптимизаций нежелателен, поэтому современные модели памяти допускают некоторые сценарии поведения, невозможные в модели SC. Такие модели памяти называются \defin{слабыми}. Например, слабыми являются модели памяти языков C++ \cite{cpp}, JavaScript \cite{js-mm} и Java \cite{jmm}, а также архитектур Power \cite{power}, x86 \cite{x86} и ARM \cite{arm}.

%Как правило, слабые модели памяти дают более сильные гарантии на поведение программ, в которых конфликтующие обращения по одному и тому же адресу должным образом синхронизированы. В противном случае такие обращения образуют \defin{гонку по данным}, и в этом случае модель памяти может ослабить гарантии на поведение программы. Так, в модели C++ к гонке по данным приводят конфликтующие неатомарные обращения, и в этом случае поведение всей программы объявляется неопределённым \cite{cpp}.
%В модели памяти Java для предотвращения гонки используются встроенные в язык средства синхронизации \cite{jmm}; в случае же возникновения гонки по некоторому адресу допускается чтение произвольных значений по нему в будущем \cite{omm}.

%Для обеспечения баланса между производительностью и предсказуемостью поведения программы современные модели памяти предоставляют программисту гарантии DRF (data race freedom, \textit{свобода от гонок}). Они гарантируют, что поведение программы, не содержащей гонок по данным, будет согласовано с моделью SC. Например, свойство DRF предоставляют модели памяти Java и Promising \cite{promising}. 

Модель памяти OCaml \cite{omm} (далее --- $\OMM$) отличается свойством т.н.  \textit{локальной свободы от гонок по данным} (local data race freedom). Именно, гарантируется, что выполнение конфликтующих обращений по выбранному адресу в памяти (т.е. ситуация гонки по данным) не влияет на обращения к другим адресам, а также на последующие обращения по тому же адресу. Благодаря этому даже при возникновении гонки по данным в некоторый момент исполнения следующие участки программы будут исполнены согласно модели SC. 

% Для того, чтобы использовать $\OMM$ на практике, необходимо доказать её реализуемость на распространённых архитектурах процессоров.
Чтобы гарантировать выполнение этого свойства, при компиляции нужно запретить некоторые оптимизации в зависимости от целевой архитектуры.
% Этого можно достичь, если в зависимости от типа инструкции при компиляции выбирать подходящие режимы доступа или добавлять барьеры в ассемблерный код.
Для этого может понадобиться, например, добавить в ассемблерный код инструкции-\defin{барьеры}, которые запрещают нежелательные оптимизации на уровне процессора. 
Набор таких правил, покрывающий все возможные типы инструкций, называется \defin{схемой компиляции}. Схема компиляции должна быть \defin{корректной} --- при исполнении любой программы, полученной при компиляции согласно этой схеме, должно наблюдаться только сценарии поведения, разрешённые $\OMM$ для исходной программы.

Авторы $\OMM$ разработали схемы компиляции $\OMM$ в модели x86-TSO и ARMv8 \cite{omm} и доказали их корректность. При этом отсутствует схема компиляции в модель архитектуры Power. А между тем данная архитектура часто используется в современном серверном оборудовании \cite{power-servers}. Задача построения такой схемы осложнена тем, что модель Power, в отличие от моделей x86-TSO, ARMv8 и $\OMM$, не обладает т.н. свойством \defin{multicopy atomicity}. Такое свойство означает, что записанные в память значения становятся доступны всем потокам в одном и том же порядке \cite{arm}. Из-за отсутствия этого свойства корректная схема компиляции $\OMM$ в Power должна расставлять барьеры в результирующей программе так, чтобы запретить нежелательные сценарии поведения. 

В рамках данной работы была поставлена задача разработать схему компиляции $\OMM$ в модель Power и доказать её корректность. Для этого было решено использовать промежуточную модель памяти (Intermediate Memory Model, далее — $\IMM$) \cite{imm}, для которой уже доказана корректность компиляции в модель Power. Использование $\IMM$ как промежуточного этапа компиляции позволяет разбить доказательство корректности  на два, которые впоследствии можно использовать в других доказательствах. Таким образом, построение схемы компиляции $\OMM$ в $\IMM$ даёт схемы компиляции $\OMM$ не только в Power, но и другие архитектуры, в которые компилируется $\IMM$ (на данный момент --- x86 и ARM). 


\section{Постановка задачи}

Целью данной работы является доказательство корректности компиляции модели памяти OCaml ($\OMM$) в модель памяти Power \cite{power}. 

В работе были поставлены следующие задачи:

\begin{itemize}
\item построение схемы компиляции $\OMM$ в $\IMM$ (для которой корректность компиляции в Power уже доказана);
\item доказательство корректности полученной схемы;
\item формализация доказательства в системе интерактивного доказательства теорем Coq \cite{coq-description}.
\end{itemize}

\section{Обзор}

В этом разделе приводится пример слабого поведения программы и объясняются его причины. Затем на примерах рассматривается понятие корректности компиляции для моделей памяти. Далее формально описывается декларативный способ задания модели памяти \cite{power}, основанный на понятии графов исполнения. Наконец, формально описываются модели памяти $\OMM$ и $\IMM$, используемые далее в работе.

\subsection{Пример исполнения в слабой модели памяти}

Рассмотрим программу, представленную на \cref{fig:store-buffering}. Здесь и далее используется упрощённый синтаксис программ: $x$ и $y$ обозначают адреса в памяти, $a$ и $b$ — локальные переменные (регистры), $\rlx$ – режим доступа (это понятие будет рассмотрено ниже). Сверху указаны изначальные значения в памяти. В комментариях указаны наблюдаемые при чтении значения. Согласно модели SC, в зависимости от порядка исполнения инструкций в $a$ и $b$ могут быть записаны значения $(1, 1)$, $(1, 0)$ или $(0, 1)$. Однако после компиляции C++-аналога этой программы с помощью компилятора gcc и исполнения на архитектуре x86 в переменные $a$ и $b$ могут быть записаны нули, что не допускается моделью SC. У такого сценария поведения могут быть две причины. Во-первых, gcc может поменять местами обращения по разным адресам во время компиляции. Во-вторых, при исполнении на x86 возможна буферизация записи: в целях оптимизации обращений к памяти запись может быть отложена. 

\begin{figure}[h]
  \centering
  \begin{tabular}{l || l}
    \multicolumn{2}{c}{$x = 0,\ y = 0$} \\
    \hline
    $\writeInst{x}{1}{\rlx}$ & $\writeInst{y}{1}{\rlx}$ \\
    $\readInst{a}{y}{0}{\rlx}$ & $\readInst{b}{x}{0}{\rlx}$ \\
  \end{tabular}
  \caption{Пример программы и её исполнения при буферизации записи}
  \label{fig:store-buffering}
\end{figure}

% Стоит отметить, что после оптимизации некоторых обращений к памяти поведение программы может перестать соответствовать спецификации.
Новые сценарии поведения программы, возникающие в результате оптимизаций, могут быть некорректными с точки зрения требований к программе. Поэтому слабая модель памяти должна предоставлять возможность отменить оптимизации для отдельных инструкций. Для этого используются \defin{режимы доступа}, различные по степени строгости.
% В зависимости от режима доступа инструкции при её компиляции могут быть отменены оптимизации, а также добавлены дополнительные инструкции-\defin{барьеры}, которые запрещают оптимизации на уровне процессора.
% Компилятор по-разному обрабатывает инструкции с разными режимами доступа; в частности, перед отдельными инструкциями могут быть
При компиляции инструкций с более строгими режимами компилятор может отменить некоторые оптимизации, а также добавить в результирующую программу инструкции-барьеры. 

Так, в программе на \cref{fig:store-buffering} был использован режим доступа $\rlx$, который не ограничивает оптимизации соответствующих инструкций. Модель памяти C++ гарантирует, что если в этой программе для всех инструкций установить режим доступа $\sco$ вместо $\rlx$, то поведение полученной программы будет согласовано с моделью SC. Это справедливо в силу того, что  такие обращения будут скомпилированы с использованием инструкции MFENCE \cite{cpp-mappings} --- барьера памяти, запрещающего перестановки SC инструкций.

\subsection{Проблема корректности компиляции на примерах} \label{corr-comp-example}

Модели $\OMM$ и $\IMM$ определены декларативно \cite{power}. Это означает, что каждое возможное поведение программы задаётся в виде \defin{графа исполнения}, а семантика программы определяется как множество графов, удовлетворяющих некоторому условию. Пример программы и одного из графов её исполнения приведён на \cref{fig:example-discriminating}.

%Метки $\na$ и $\at$ в программе на \cref{fig:example-discriminating} обозначают \defin{режимы доступа} соответствующих инструкций. Режимы доступа назначаются программистом для отмены оптимизаций отдельных инструкций. Так, запись в режиме $\at$ на архитектуре x86 компилируется\cite{omm} в инструкцию атомарной замены \texttt{xchg}, перед исполнением которой буфер записей очищается, что ограничивает множество возможных поведений программы.

Вершины графа соответствуют событиям --- операциям над разделяемой памятью, которые производятся при выполнении инструкций программы. Так, событие $\lW^{\at}(x, 1)$ соответствует записи по адресу $x$ значения $1$ в режиме $\at$; другими типами событий являются чтение и барьер памяти (обозначаются $\lR$ и $\lF$ соответственно). Кроме того, в графе выделяются инициализирующие события, которые соответствуют инициализирующей записи нулей в память. На \cref{fig:example-discriminating} все они для краткости обозначены множеством $\mathtt{Init}$; далее в графах мы будем опускать эти события, если это не будет важно для рассуждений. Заметим, что содержимое локальных переменных потока не отражается в графе в явном виде, т.к. взаимодействие между потоками производится только через разделяемую память. 

\begin{figure}[h]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{l || l || l}
      \multicolumn{3}{c}{$\writeInst{x}{0}{}\ \writeInst{y}{0}{}$} \\
      \hline
      $\writeInst{x}{1}{\at}$ & $\readInst{a}{x}{1}{\at}$ & $\readInst{b}{y}{1}{\na}$ \\
      {}            & $\writeInst{y}{1}{\na}$ & $\readInst{c}{x}{0}{\at}$ \\
    \end{tabular}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[yscale=1,xscale=1]
      \node (Winit) at (3,1) {$\mathtt{Init}$};
      
      \node (T1W1) at (0, -1.5) {$\wlab{\at}{x}{1}$};
      \dcoext{Winit}{T1W1}{bend right=30}{left};
      
      \node (T2R1) at (3,0) {$\rlab{\at}{x}{1}$};
      \drf{T1W1}{T2R1};
      \node (T2W1) at (3, -1.5) {$\wlab{\na}{y}{1}$};
      \dpo{T2R1}{T2W1};
      \dcoext{Winit}{T2W1}{bend right=70}{left};
      
      \node (T3R1) at (6,0) {$\rlab{\na}{y}{1}$};
      \drf{T2W1}{T3R1};
      \node (T3R2) at (6,-1.5) {$\rlab{\at}{x}{0}$};
      \dpo{T3R1}{T3R2}; 
      \drf{Winit}{T3R2};
      \dfr{T3R2}{T1W1}{bend left=10};
    \end{tikzpicture}
  \end{minipage}
  \caption{Пример программы и сценария её исполнения, не согласованного в $\OMM$}
  \label{fig:example-discriminating}
\end{figure}

Рёбра графа задают бинарные отношения между событиями. В данном графе есть четыре
различных отношения: рёбра $\lPO$ соответствуют программному порядку инструкций, $\lRF$ --- чтению записанного ранее значения, $\lCO$ --- порядку выполнения записи по одному адресу, $\lFR$ --- чтению до указанного события записи. Отношения $\lPO$ и $\lCO$ являются транзитивными, поэтому для их задания достаточно указывать только непосредственные рёбра. Кроме того, для краткости будем опускать подпись $\lPO$ рядом с соответствующими рёбрами.

\defin{Согласованными} (допустимыми моделью) называются те сценарии исполнения программы, графы которых удовлетворяют некоторому предикату, заданному моделью. В частности, предикат согласованности $\OMM$ требует, чтобы в графе не было циклов, состоящих только из рёбер $\lCO$ и $\lFR$, проходящих между вершинами с меткой $\at$, а также рёбер $\lPO$ и $\lRF$. Это условие формализует свойство multicopy atomicity, описанное выше.

Граф исполнения на \cref{fig:example-discriminating} не является согласованным по $\OMM$. Действительно, этот сценарий исполнения нарушает свойство multicopy atomicity: второй поток читает записанное в $x$ значение $1$ до записи $1$ в $y$, однако третий поток читает старое значение $0$ из $x$ после чтения $1$ из $y$. Соответствующий граф исполнения не удовлетворяет предикату согласованности $\OMM$, так как между вершинами есть цикл, подходящий под описание выше. Таким образом, в $\OMM$ после исполнения программы на \cref{fig:example-discriminating} переменные $a$, $b$ и $c$ не могут содержать значения $1$, $1$ и $0$ соответственно.

Условие корректности компиляции требует, чтобы сценарии поведения, запрещённые для исходной программы в $\OMM$, также были запрещены для скомпилированной программы в $\IMM$. Для декларативных моделей памяти это означает, что из несогласованности графа исполнения в $\OMM$ должна следовать несогласованность соответствующего ему графа исполнения  в $\IMM$. При этом, как будет показано далее, можно рассматривать вопрос согласованности по $\OMM$ только для графа исполнения скомпилированной программы.

На \cref{fig:example-imm-consistent} приведён результат компиляции программы на \cref{fig:example-discriminating} согласно тривиальной схеме компиляции. 
Такая схема лишь заменяет режимы инструкций на их аналоги в $\IMM$: $\na$ заменяется на $\rlx$, а $\at$ — на $\sco$; дополнительных инструкций не вводится. Соответственно, граф исполнения на \cref{fig:example-imm-consistent} отличается от графа на \cref{fig:example-discriminating} только метками вершин, и в нём сохраняется цикл того же вида. $\IMM$ не гарантирует свойство multicopy atomicity, и потому предикат её согласованности не требует отсутствия таких циклов. Поэтому граф на \cref{fig:example-imm-consistent} согласован, что делает соответствующий ему сценарий поведения разрешается $\IMM$, в отличие от $\OMM$. Поэтому тривиальная схема компиляции не является корректной.

\begin{figure}[h]
  \centering
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tabular}{l || l || l}
      \multicolumn{3}{c}{$\writeInst{x}{0}{}\ \writeInst{y}{0}{}$} \\
      \hline
      $\writeInst{x}{1}{\sco}$ & $\readInst{a}{x}{1}{\sco}$ & $\readInst{b}{y}{1}{\rlx}$ \\
      {}            & $\writeInst{y}{1}{\rlx}$ & $\readInst{c}{x}{0}{\sco}$ \\
    \end{tabular}
  \end{minipage}\hfill
  \begin{minipage}{0.45\textwidth}
    \centering
    \begin{tikzpicture}[yscale=1,xscale=1]
      
      \node (T1W1) at (0, -1.5) {$\wlab{\sco}{x}{1}$};
      
      \node (T2R1) at (3,0) {$\rlab{\sco}{x}{1}$};
      \drf{T1W1}{T2R1};
      \node (T2W1) at (3, -1.5) {$\wlab{\rlx}{y}{1}$};
      \dpo{T2R1}{T2W1};
      
      \node (T3R1) at (6,0) {$\rlab{\rlx}{y}{1}$};
      \drf{T2W1}{T3R1};
      \node (T3R2) at (6,-1.5) {$\rlab{\sco}{x}{0}$};
      \dpo{T3R1}{T3R2}; 
      % \dfr{T3R2}{T1W1}{bend left=20};
      \draw[fr, bend left=20] (T3R2) edge node[left, yshift=1ex] {$\lFR$}(T1W1);
    \end{tikzpicture}
  \end{minipage}
  \caption{Результат компиляции программы на \cref{fig:example-discriminating} с использованием тривиальной схемы компиляции и согласованный по $\IMM$ граф его исполнения}
  \label{fig:example-imm-consistent}
\end{figure}

На \cref{fig:example-imm-inconsistent} приведена программа, полученная в результате компиляции программы на \cref{fig:example-discriminating} согласно схеме компиляции, приведённой в разделе \ref{compilation-scheme}. В результате компиляции в ней появляются инструкции барьеров памяти, запрещающие некоторые оптимизации процессора и компилятора. С этими барьерами граф исполнения перестаёт быть согласованным: из рёбер $\lRF$ между событиями с меткой $\sco$, а также $\lFR$, $\lPO$ и окружённого барьерами $\lRF$ образуется цикл, запрещённый в $\IMM$.


\newcommand{\vsIV}{-1.2}
\newcommand{\hsIV}{2.2}

\newcommand{\inconsistentExample}[1]{
      \begin{tikzpicture}[yscale=1,xscale=1]
      
      \node (T1F1) at (0, 0) {$\flab{\acq}$};
      \node (T1R1) at (0, \vsIV * 1) {$\rlab{\sco}{x}{0}$};
      \dpo{T1F1}{T1R1};
      \node (T1W1) at (0, \vsIV * 2) {$\wlab{\sco}{x}{1}$};
      \dpo{T1R1}{T1W1};
      \drmw{T1R1}{T1W1};
      
      \node (T2F1) at (\hsIV,0) {$\flab{\acq}$};
      \node (T2R1) at (\hsIV,\vsIV * 1) {$\rlab{\sco}{x}{1}$};
      \dpo{T2F1}{T2R1};
      \drf{T1W1}{T2R1};
      \node (T2F2) at (\hsIV,\vsIV * 2) {$\flab{\acqrel}$};
      \dpo{T2R1}{T2F2};
      \node (T2W1) at (\hsIV,\vsIV * 3) {$\wlab{\rlx}{y}{1}$};
      \dpo{T2F2}{T2W1};
      
      \node (T3R1) at (\hsIV * 2,0) {$\rlab{\rlx}{y}{1}$};
      \drf{T2W1}{T3R1};
      \node (T3F1) at (\hsIV * 2,\vsIV * 1) {$\flab{\acq}$};
      \dpo{T3R1}{T3F1};
      \node (T3R2) at (\hsIV * 2,\vsIV * 2) {$\rlab{\sco}{x}{0}$};
      \dpo{T3F1}{T3R2};
      % \dhb{T2F2}{T3F1}{bend right=5};
      \dfr{T3R2}{T1W1}{bend left=#1};
    \end{tikzpicture}
  }

\begin{figure}[!h]
%   % foobar
  % \centering
  \begin{minipage}{0.45\textwidth}
    % \centering
    \begin{tabular}{l || l || l}
      \multicolumn{3}{c}{$\writeInst{x}{0}{}\ \writeInst{y}{0}{}$} \\
      \hline
      $\fenceInst{\acq}$ & $\fenceInst{\acq}$ & $\readInst{b}{y}{1}{\rlx}$ \\
      $\exchangeInstSC{x}{1}$ & $\readInst{a}{x}{1}{\sco}$ & $\fenceInst{\acq}$\\
      {} & $\fenceInst{\acqrel}$ & $\readInst{c}{x}{0}{\sco}$\\
      {} & $\writeInst{y}{1}{\rlx}$ & {} \\
    \end{tabular}
    % bar
  \end{minipage} \hfill
  \begin{minipage}{0.45\textwidth}
    % \centering
    \inconsistentExample{70}
    % foo
  \end{minipage}

  % \caption{foobar}
  % \captionof{figure}{boofar}
  % \caption{Результат компиляции программы на \cref{fig:example-discriminating} с использованием схемы компиляции из раздела \ref{compilation-scheme} и его граф исполнения, не согласованный в $\IMM$}
  {\todo{Компиляция падает, если здесь использовать caption} Результат компиляции программы на \cref{fig:example-discriminating} с использованием схемы компиляции из раздела \ref{compilation-scheme} и его граф исполнения, не согласованный в $\IMM$}
  \label{fig:example-imm-inconsistent}    
\end{figure}

Таким образом, для доказательства корректности компиляции необходимо доказать
следующую теорему\footnote{Формальное понятие соответствие графов вводится в разделе \ref{compilation-scheme}.}.

\begin{restatable}{thm}{compiletheorem}
% \begin{definition}
  \label{prop:compile-theorem}
  Пусть $PO=||_{\tau\in \Tid} PO_\tau$ и $PI=||_{\tau\in \Tid} PI_\tau$ --- программы для моделей $\OMM$ и $\IMM$ соответственно, причём для любого $\tau \in \Tid$ подпрограмма $PI_\tau$ получена компиляцией $PO_\tau$ с помощью схемы компиляции из \cref{table:scheme}. Пусть $G_I$ --- согласованный по $\IMM$ граф исполнения $PI$. Тогда существует $G_O$ --- согласованный по $\OMM$ граф исполнения $PO$, соответствующий $G_I$. 
\end{restatable}


Ключевой идеей доказательства является то, что согласованность по $\OMM$ можно рассматривать для обоих графов исполнения. Для доказательства теоремы достаточно показать, что $G_I$ является согласованным по $\OMM$. Из этого следует согласованность $G_O$ по $\OMM$, так как он фактически является подграфом $G_I$ , а условия согласованности по $\OMM$ таковы, что выполняются для подграфов. Условие согласованности по $\OMM$ состоит в иррефлексивности одного отношения и ацикличности другого. Для каждого из этих отношений доказывается включение в такое отношение, для которого соответствующее условие выполняется в согласованном по $\IMM$ графе.

\subsection{Графы исполнения}
\label{exec-graphs}

В описаниях декларативных моделей памяти мы будем использовать следующие обозначения отношений между вершинами. Для бинарного отношения $R$ обозначения $R^?$, $R^{+}$, $R^{*}$ соответствуют его рефлексивному, транзитивному и транзитивно-рефлексивному замыканиям соответственно. Обратное отношение записывается как $R^{-1}$. Левая композиция отношений $R_1$ и $R_2$ записывается следующим образом:

$R_1;R_2 \defeq \set{x, y | \exists z. (x, z) \in R_1 \land (z, y) \in R_2}$.

Непосредственные рёбра $R$ обозначаются как $\imm R \defeq R \backslash R;R$. Тождественное отношение на множестве $A$ обозначается как $[A]$; в частности, $[A];R;[B] = R \cap (A \times B)$.

В данном разделе описываются графы исполнения наиболее общего вида, без привязки к конкретным моделям памяти или языкам. 

Считаем, что анализируемая программа $P$ состоит из последовательных подпрограмм отдельных потоков $P_\tau$: $P = ||_{\tau\in \Tid} P_\tau$, где $||$ --- оператор параллельной композиции программ, а $\Tid$ --- конечное множество идентификаторов потоков.

% \begin{definition}
\begin{restatable}{mydefinition}{graph}
  \emph{Граф исполнения} $G$ задаётся множеством вершин, бинарными отношениями на вершинах, а также функцией, сопоставляющей вершинами \emph{метки}. 
\end{restatable}
%\end{definition}
  
  Множество вершин, обозначаемое как $G.\lE$, делится на инициализирующие события вида $\mathtt{Init}\ loc$ и неинициализирующие события вида $\mathtt{ThreadEvent}\ \tau\ n$. Их компонентами являются:
  \begin{itemize}
  \item $loc \in \Loc$ --- адрес инициализации, где $\Loc$ --- конечное множество адресов;
  \item $\tau \in \Tid$ --- номер потока;
  \item $n\in \mathbb{N}$ --- порядковый номер внутри потока.
  \end{itemize}
    
Функция $G.\Lab$ сопоставляет событиям \term{метки} вида $(type, loc, mode, val)$. Их компонентами являются:
\begin{itemize}
\item $type \in \{\lR, \lW, \lF\}$ --- тип операции (чтение, запись, барьер);
\item $loc \in \Loc$ --- адрес памяти (для барьера не определено);
\item $mode$ --- один из режимов доступа (например, $\rel$), частично упорядоченных отношением ``строже чем'' ($\sqsubset$); конкретное множество режимов и их порядок определяется моделью памяти;
\item $val\in \Val$ --- прочитанное/записанное значение (в случае барьера не определено), где $\Val$ --- множество значений, которые могут храниться в памяти.
\end{itemize}

Следует отметить, что инициализирующие события вида $\mathtt{Init}\ loc$ обрабатываются особым образом. Именно,

$G.\Lab(\mathtt{Init}\ loc) = (\lW, loc, mode_{\Init}, val_{\Init})$, где $mode_{\Init}$ --- выбранный режим доступа для инициализирующих событий записей (например, в $\IMM$ --- $\rlx$), а $val_{\Init}$ --- начальное значение в памяти (как правило, 0).

Для множеств событий с определёнными метками вводятся соответствующие обозначения. Например, события с меткой чтения в режиме $\acq$ или более строгим будем обозначать как $G.\lR^{\acq}$ (или просто $\lR^{\acq}$, если граф очевиден из контекста).

Рёбра графа представляют собой следующие отношения между событиями:
\begin{itemize}
\item программный порядок (program order): $G.\lPO(x, y)\!\! \iff \!\! (x\in \Init \land y\notin \Init) \lor (x.\tau = y.\tau \land x.n<y.n)$;
\item порядок согласованности (coherence order): $G.\lCO = \bigcup_{l\in \Loc} \lCO_l$, где $\lCO_l$ --- тотальный порядок на событиях записи по адресу $l$;
\item наблюдение записанного значения (``читает-из'', reads from):

  $G.\lRF \subseteq \bigcup_{l\in \Loc} G.\lW_l \times G.\lR_l$, где

  $G.\lRF(w, r)\implies G.\Lab(w).val = G.\Lab(r).val$, $codom(G.\lRF) = G.\lR$ и

  $G.\lRF^{-1}$ является функциональным отношением;
\item чтение до указанной записи: $G.\lFR = G.\lRF^{-1}; G.\lCO$ (from-read, ``читает-\allowbreak до'').
\end{itemize}  

Различные модели памяти могут иметь в графе исполнения и другие отношения. Например, в модели $\IMM$ также есть отношение $\lRMW \subseteq \bigcup_{l\in \Loc}[G.\lR_l];\imm\lPO;[G.\lW_l]$, соответствующее паре событий чтения и записи в операции read-modify-write. 

Введём понятия сужения графа на поток $i$: $G_\tau.\lE = \{e\in G.\lE\ |\ e.\tau = i\}$, $G_\tau.\Lab = G.\Lab$.

\begin{restatable}{mydefinition}{execution}
% \begin{definition}
\term{Графом исполнения программы} $P$ называется такой граф $G$, что его сужение на любой поток $\tau\in \Tid$ является \term{однопоточным графом исполнения} программы $P_\tau$.
% \end{definition}
\end{restatable}

Соответствие подпрограммы потока и однопоточного графа исполнения определяется средствами операционной семантики, специфичной для модели памяти \cite{omm}, \cite{imm}. Мы не приводим подробностей здесь, скажем лишь, что такая семантика задаёт соответствие между выполнением инструкций языка и изменением графа исполнения. Так, для $\IMM$ выполнение инструкции $[x]^{\rel}\;:=\;1$ соответствует добавлению в текущий граф вершины с очередным порядковым номером и меткой вида $\lW^\rel(x, 1)$, а также рёбер, отражающих синтаксические зависимости данного события.

\begin{restatable}{mydefinition}{outcome}
  \label{definition:outcome-def}
  Граф исполнения определяет \emph{сценарий поведения} программы --- функцию ${f: \Loc \to \Val}$, отображающую адрес в последнее (согласно порядку $\lCO$) записанное по нему значение. 
\end{restatable}

Декларативная модель памяти задаётся предикатом согласованности, которому должны удовлетворять графы исполнения программ.
\begin{restatable}{mydefinition}{outcome}
  Сценарий поведения программы является \emph{согласованным} по модели памяти $M$, если он задан некоторым графом её исполнения, удовлетворяющим предикату согласованности $M$.
\end{restatable}  

\subsection{Описание используемых моделей памяти}
% \label{mm-description}

В данном разделе описываются рассматриваемые модели памяти ---  $\OMM$ и $\IMM$, --- а также их предикаты
согласованности.

\subsubsection{Модель памяти OCaml ($\OMM$)}
% \label{ocaml-mm}

% По сравнению с другими моделями памяти, предоставляющим DRF гарантии, $\OMM$ отличается более сильным свойством --- Local Data Race Freedom (локальная свобода от гонок). Оно гарантирует, что влияние гонок по данным на поведение программы ограничено по области памяти и по времени.
% Именно, гарантируется, что исполнение конфликтующих обращений по выбранному адресу в памяти не влияет на обращения к другим адресам, а также на последующие обращения по тому же адресу. 
% Таким образом, поведение при исполнении всех участков программы, не содержащих гонок по данным, согласовано с моделью SC. Благодаря этому даже при возникновении гонки по данным в некоторый момент исполнения следующие участки программы будут исполнены в соответствии с моделью SC, чего не гарантируется обычными DRF теоремами. 

Модель памяти OCaml ($\OMM$) \cite{omm} задана эквивалентными операционным и декларативным описаниями. Для доказательства корректности компиляции будет использоваться декларативное описание.

$\OMM$ поддерживает два режима доступа: неатомарный $\na$ и атомарный $\at$ (схожи с $\pln$ и $\sco$ в C++). При этом память также разделена на неатомарные и атомарные адреса, и к конкретному адресу можно обратиться только операцией соответствующего режима.

В графе исполнения $\OMM$ есть только операции чтения и записи, барьеры отсутствуют.

Перед рассмотрением предиката согласованности введём ещё несколько обозначений. Для отношения $R$ в графе исполнения будем обозначать $Ri$ рёбра $R$, проходящие между вершинами одного потока, а $Re$ --- между вершинами разных потоков. 

\begin{restatable}{mydefinition}{omm-consistent}
% \begin{definition}
  Сценарий исполнения называется \term{согласованным по $\OMM$}, если в соответствующем графе исполнения выполняются следующие аксиомы:

  \begin{enumerate}
  \item последовательная согласованность по отдельным адресам (SC per location, coherence): отношение $\lHBO ; (\lCO \cup \lFR)$ иррефлексивно, где

    $\lHBO \defeq \lPO \cup [\lE^{\at}] ; (\lRF \cup \lCO) ; [\lE^{\at}]$;
    
  \item отсутствие буферизации при чтении (load buffering): отношение $\lPO \cup \lRFE \cup [\lE^{\at}] ; (\lCOE \cup \lFRE) ; [\lE^{\at}]$ ациклично.
  \end{enumerate}
% \end{definition}
\end{restatable}

% \subsubsection{Промежуточная модель памяти}

% @misc{coq-description,
%     author    = "Coq development team",
%     title     = "The Coq Proof Assistant",
%     howpublished = {\url{https://coq.inria.fr/}},
%     langid = {english},
%     year = {2020},
% }

% Промежуточная модель памяти ($\IMM$) определена декларативно. Полный предикат согласованности $\IMM$ достаточно сложен, поэтому мы рассмотрим лишь часть модели, которая будет необходима для построения схемы компиляции. Перед этим введём ещё несколько обозначений. $R_{loc}$ будем обозначать рёбра $R$, проходящие между вершинами с метками одного и того же адреса, $R_{\neq loc}$ --- между вершинами с метками разных адресов.

% Синтаксис программ на $\IMM$ напоминает таковой в C++ --- помимо инструкций атомарного чтения и записи есть инструкции барьеров памяти, а также операций read-modify-write. В граф исполнения программы на $\IMM$, помимо отношений, перечисленных в разделе \ref{exec-graphs}, также входит отношение, связывающее события чтения и записи, которые совершаются при операции read-modify-write:

% $G.\lRMW \subseteq ([G.\lR] ;\imm \lPO;[G.\lW])_{loc}$. 

% Для построения схемы компиляции мы пользуемся расширением \cite{imm-sc} $\IMM$, которое дополняет оригинальную модель \cite{imm} $\sco$-операциями. 

% \begin{restatable}{mydefinition}{imm-consistent}
%   % \begin{definition}
%   Сценарий исполнения называется \term{согласованным по $\IMM$}, если в соответствующем графе исполнения выполняются следующие аксиомы:
%   \begin{enumerate}
%   \item отношение $\lHB ; (\lRF \cup \lCO \cup \lFR)^{+}$ иррефлексивно, при этом справедливо следующее:
    
%   $\lHB \defeq (\lPO \cup \lSW)^{+}$

%   $\lSW \defeq \mathtt{\color{blue}release};(\lRFI \cup \lPO^?_{loc};\lRFE);([\lR^{\acq}] \cup \lPO;[\lF^{\acq}])$

%   $\mathtt{\color{blue}release} \defeq ([\lW^{\rel}] \cup [\lF^{\rel}];\lPO);\mathtt{\color{blue}rs}$

%   $\mathtt{\color{blue}rs} \defeq [\lW];\lPO_{loc};[\lW] \cup [\lW];(\lPO^?_{loc};\lRFE;\lRMW)^{*}$;
% \item операции read-modify-write являются атомарными:

%   $\lRMW \cap (\lFRE ; \lCOE) = \emptyset$;
%   \item отношение $\lAR$ ациклично, при этом справедливо следующее:

%     $\lAR \supset \lRFE \cup \lBOB$

%     $\lBOB \supset [\lR^{\acq}] ; \lPO \cup \lPO ; [\lF] \cup [\lF] ; \lPO$;
%   \item отношение $\lPSCB$ ациклично, при этом справедливо следующее:

%     $\lPSCB \defeq ([\lE^\sco] \cup{} [\lF^\sco];\lHB^?);\lSCB;([\lE^\sco] \cup{} \lHB^?;[\lF^\sco])$

%     $\lSCB \defeq \lPO \cup \lPO_{\neq loc} ; \lHB ; \lPO_{\neq loc} \cup \lHB_{loc} \cup \lCO \cup \lFR$.

%   \end{enumerate}
% % \end{definition}
% \end{restatable}



\bibliographystyle{ugost2008ls}
\bibliography{Namakonov/sources}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
